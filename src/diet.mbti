// Generated using `moon info`, DON'T EDIT IT
package "CAIMEOX/diet"

// Values
fn[N : BoundedEnum] difference(Tree[N], Tree[N]) -> Tree[N]

fn[N] empty() -> Tree[N]

fn[N] interval(N, N) -> Tree[N]

fn[N : BoundedEnum] is_subset(Tree[N], Tree[N]) -> Bool

fn[N : BoundedEnum] of(Array[N]) -> Tree[N]

fn[N : BoundedEnum] of_view(ArrayView[N]) -> Tree[N]

fn[N] singleton(N) -> Tree[N]

// Errors

// Types and methods
type Tree[T]
fn[N : BoundedEnum] Tree::add(Self[N], N) -> Self[N]
fn[N : BoundedEnum] Tree::complement(Self[N]) -> Self[N]
fn[N : BoundedEnum] Tree::contains(Self[N], N) -> Bool
fn[N : BoundedEnum, A] Tree::fold_ranges(Self[N], init~ : A, (A, N, N) -> A) -> A
fn[N : BoundedEnum] Tree::intersection(Self[N], Self[N]) -> Self[N]
fn[N] Tree::is_empty(Self[N]) -> Bool
fn[N : BoundedEnum] Tree::iter(Self[N]) -> Iter[N]
fn[N] Tree::iter_intervals(Self[N]) -> Iter[(N, N)]
fn[N : BoundedEnum] Tree::remove(Self[N], N) -> Self[N]
fn[N : BoundedEnum] Tree::slice(Self[N], min? : N, max? : N) -> Self[N]
fn[N : BoundedEnum] Tree::slice_after(Self[N], N) -> Self[N]
fn[N : BoundedEnum] Tree::slice_before(Self[N], N) -> Self[N]
fn[N : BoundedEnum] Tree::slice_from(Self[N], N) -> Self[N]
fn[N : BoundedEnum] Tree::slice_until(Self[N], N) -> Self[N]
fn[N : BoundedEnum] Tree::union(Self[N], Self[N]) -> Self[N]
impl[N : Compare] Compare for Tree[N]
impl[N] Default for Tree[N]
impl[N : Eq] Eq for Tree[N]
impl[N : Hash] Hash for Tree[N]

// Type aliases
pub typealias Tree as T

// Traits
pub(open) trait BoundedEnum : Compare {
  pred(Self) -> Self
  succ(Self) -> Self
  lower_bound() -> Self
  upper_bound() -> Self
}
impl BoundedEnum for Char
impl BoundedEnum for Int

